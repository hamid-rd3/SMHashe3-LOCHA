/*
 * This file is what a rendered Platform.h file might look like.
 * It is for reference only!
 * This file is NEVER referenced during the build.
 */

/*
 * DO NOT EDIT THIS FILE
 *
 * It is generated by CMake during build configuration.
 * See /home/username/smhasher3/platform/functions.cmake
 * for documentation on how and why this is generated.
 */
/*
 * SMHasher3
 * Copyright (C) 2021-2022  Frank J. T. Wojcik
 *
 * This program is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see
 * <https://www.gnu.org/licenses/>.
 */
#include <cstdio>    // Allow printf() from anywhere
#include <cstring>   // For memcpy

//-----------------------------------------------------------------------------
// Fixed-width integers (required before all else)
#include <cstdint>
typedef unsigned __int128 uint128_t;
typedef          __int128  int128_t;
#define HAVE_INT128
typedef uint64_t  seed_t; 
#include <inttypes.h>

//-----------------------------------------------------------------------------
// MSVC-specific things (if required)


//-----------------------------------------------------------------------------
// Declarations for Platform.cpp
void DisableThreads(void);

//-----------------------------------------------------------------------------
// Compiler-specific functions and macros

// Compiler branching hints
#define likely(x)   __builtin_expect(!!(x), 1)
#define unlikely(x) __builtin_expect(!!(x), 0)
#define expectp(x,p) __builtin_expect_with_probability(!!(x), 1, (p))
#define unpredictable(x) __builtin_expect_with_probability(!!(x), 1, 0.5)

// Compiler behavioral bounds hints
#define assume(x) ((void)((x) ? 1 : (unreachable(), 1)))
#define unreachable() __builtin_unreachable()

// Compiler/CPU data prefetching
#define prefetch(ptr) __builtin_prefetch(ptr)

// Function inlining control
#define FORCE_INLINE __attribute__((__always_inline__)) inline
#define NEVER_INLINE __attribute__((__noinline__))

// C "restrict" keyword replacement
#define RESTRICT __restrict

// Integer rotation
// CAUTION: These are deliberately unsafe!
// They assume the rotation value is not 0 or >= {32,64}.
// If an invalid rotation amount is given, the result is undefined behavior.
static inline uint32_t _rotl32(uint32_t v, uint8_t n) {
    return (v << n) | (v >> ((-n) & 31));
}
static inline uint32_t _rotr32(uint32_t v, uint8_t n) {
    return (v >> n) | (v << ((-n) & 31));
}
#define ROTL32(v, n) _rotl32(v, n)
#define ROTR32(v, n) _rotr32(v, n)
static inline uint64_t _rotl64(uint64_t v, uint8_t n) {
    return (v << n) | (v >> ((-n) & 63));
}
static inline uint64_t _rotr64(uint64_t v, uint8_t n) {
    return (v >> n) | (v << ((-n) & 63));
}
#define ROTL64(v, n) _rotl64(v, n)
#define ROTR64(v, n) _rotr64(v, n)

// Population count (popcnt/popcount)
#define popcount4(x) __builtin_popcount(x)
#define popcount8(x) __builtin_popcountll(x)

// Leading zero-bit count (ffs/clz)
// CAUTION: Assumes x is not 0!
#define clz4(x) __builtin_clz(x)
#define clz8(x) __builtin_clzll(x)

// Integer byteswapping (endianness conversion)
// You can use the bit-specific ones directly, but the more generic
// versions below are preferred.
#define BSWAP16(x) __builtin_bswap16(x)
#define BSWAP32(x) __builtin_bswap32(x)
#define BSWAP64(x) __builtin_bswap64(x)

//-----------------------------------------------------------------------------
// Generic wrappers for BSWAP*()
template < typename T >
static FORCE_INLINE T BSWAP(T value) {
    switch(sizeof(T)) {
    case 2: value = BSWAP16((uint16_t)value); break;
    case 4: value = BSWAP32((uint32_t)value); break;
    case 8: value = BSWAP64((uint64_t)value); break;
    default: break;
    }
    return value;
}

template < typename T >
static FORCE_INLINE T COND_BSWAP(T value, bool doit) {
    if (!doit || (sizeof(T) < 2)) { return value; }
    return BSWAP(value);
}

//-----------------------------------------------------------------------------
// User-configurable implementations

// Endianness detection
static FORCE_INLINE bool isLE(void) { return true; }
static FORCE_INLINE bool isBE(void) { return false; }

// Threading includes and global state
#if defined(HAVE_THREADS)
  #include <thread>
  extern unsigned g_NCPU;
#else
  extern const unsigned g_NCPU;
#endif

//-----------------------------------------------------------------------------
// Routines for turning bytes in memory into integers. These move data
// in alignment-safe ways, with optional byte swapping.
//
// memcpy() is the only known way of safely moving data this way;
// "safe" meaning "defined C++ behavior" AND "working regardless of
// alignment". Every memcpy() call here has a fixed size, and modern
// compilers tend to inline these into alignment-safe data moves/loads
// that are best for the platform being compiled for. Earlier
// compilers did not always do this very well, at least on non-x86
// platforms.
//
// If someone ever wanted to allow hashes to use undefined-behavior
// for faster access, this is where different access methods could be
// introduced, such as reading through a union or just doing direct
// memory access by pointer type conversion. Both of those are
// undefined behavior (UB), though! Beware of nasal demons!
//
// It's also plausible to introduce different versions of these which
// handle known-to-be-aligned accesses in a different way, perhaps
// through another template parameter.

template < bool bswap >
static FORCE_INLINE uint64_t GET_U64(const uint8_t * b, const uint32_t i) {
    uint64_t n;
    memcpy(&n, &b[i], 8);
    n = COND_BSWAP(n, bswap);
    return n;
}

template < bool bswap >
static FORCE_INLINE uint32_t GET_U32(const uint8_t * b, const uint32_t i) {
    uint32_t n;
    memcpy(&n, &b[i], 4);
    n = COND_BSWAP(n, bswap);
    return n;
}

template < bool bswap >
static FORCE_INLINE uint16_t GET_U16(const uint8_t * b, const uint32_t i) {
    uint16_t n;
    memcpy(&n, &b[i], 2);
    n = COND_BSWAP(n, bswap);
    return n;
}

template < bool bswap >
static FORCE_INLINE void PUT_U16(uint16_t n, uint8_t * b, const uint32_t i) {
    n = COND_BSWAP(n, bswap);
    memcpy(&b[i], &n, 2);
}

template < bool bswap >
static FORCE_INLINE void PUT_U32(uint32_t n, uint8_t * b, const uint32_t i) {
    n = COND_BSWAP(n, bswap);
    memcpy(&b[i], &n, 4);
}

template < bool bswap >
static FORCE_INLINE void PUT_U64(uint64_t n, uint8_t * b, const uint32_t i) {
    n = COND_BSWAP(n, bswap);
    memcpy(&b[i], &n, 8);
}

//-----------------------------------------------------------------------------
// Debugging helpers
//
// Really wish these could be moved into the CMake generation-time
// detection, but I can't find a reliable way of checking if "-DDEBUG"
// will be passed to the compiler.

#if defined(DEBUG)
  #include <cassert>

  #undef assume
  #define assume(x) assert(x)

  #undef unreachable
  #define unreachable() assert(0)

  #define verify(x) assert(x)
#else
  static void warn_if(bool x, const char * s, const char * fn, uint64_t ln) {
      if (!x) {
          printf("Statement %s is not true: %s:%" PRId64 "\n", s, fn, ln);
      }
  }
  #define verify(x) warn_if(x, #x, __FILE__, __LINE__)
#endif

//-----------------------------------------------------------------------------
// Instruction-set architecture header detection, for internal use only

/* #undef HAVE_ARM_NEON */
/* #undef HAVE_ARM_ACLE */
#define HAVE_IMMINTRIN
/* #undef HAVE_AMMINTRIN */
#define HAVE_X86INTRIN

//-----------------------------------------------------------------------------
// Instruction-set architecture and platform feature availability

/* #undef HAVE_32BIT_PLATFORM */

#define HAVE_SSE_2
#define HAVE_SSSE_3
#define HAVE_SSE_4_1
/* #undef HAVE_XOP */
#define HAVE_X86_64_CRC32C
#define HAVE_X86_64_CLMUL
#define HAVE_X86_64_AES
#define HAVE_X86_64_SHA1
#define HAVE_X86_64_SHA2
#define HAVE_AVX
#define HAVE_AVX2
/* #undef HAVE_AVX512_F */
/* #undef HAVE_AVX512_BW */
/* #undef HAVE_UMULH */
/* #undef HAVE_UMUL128 */
#define HAVE_X86_64_ASM
/* #undef HAVE_ARM_AES */
/* #undef HAVE_ARM_SHA1 */
/* #undef HAVE_ARM_SHA2 */
/* #undef HAVE_ARM_ASM */
/* #undef HAVE_ARM64_ASM */
/* #undef HAVE_PPC_VSX */
/* #undef HAVE_PPC_AES */
/* #undef HAVE_PPC_ASM */

/* #undef HAVE_BROKEN_MSVC_CRC32C_HW */
